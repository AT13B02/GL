//*****************************************************************************
//
// 軸平行バウンディングボックスクラス
//
// Author		: Ryo Kobayashi
//
//*****************************************************************************

//*****************************************************************************
// インクルード
//*****************************************************************************
#include "axis_aligned_bounding_box.h"

//=============================================================================
// ボックスの中心点を返す
//=============================================================================
VECTOR3 AABB::center(void) const
{
	return VECTOR3((Min._x + Max._x) * 0.5f, (Min._y + Max._y) * 0.5f, (Min._z + Max._z) * 0.5f);
}

//=============================================================================
// ボックスの各辺の長さを返す
//=============================================================================
VECTOR3 AABB::size(void) const
{
	return (Max - Min);
}

//=============================================================================
// X軸方向の長さを返す
//=============================================================================
f32 AABB::width(void) const
{
	return (Max._x - Min._x);
}

//=============================================================================
// Y軸方向の長さを返す
//=============================================================================
f32 AABB::height(void) const
{
	return (Max._y - Min._y);
}

//=============================================================================
// Z軸方向の長さを返す
//=============================================================================
f32 AABB::depth(void) const
{
	return (Max._z - Min._z);
}

//=============================================================================
// 指定したインデックス(0 ~ 7)からAABBの頂点を取得
// 左手系と考え
// Z軸を負から正の方向へ見た場合
// (5)1----2(6)
//    |    |
//    |    |
// (4)0----3(7)
// という番号付けにする(即席で平面を作りたいとき以外あまり気にする必要はないかも)
//=============================================================================
VECTOR3 AABB::corner(s32 nIndex) const
{
	VECTOR3 temp(FLT_MAX, FLT_MAX, FLT_MAX);

	// インデックスが不正な値をさしていないか検査
	if(nIndex < 0 || nIndex >= 8)
	{
		// どうしようもない値を返す
		return temp;
	}

	// インデックスによって返す値を決める
	switch(nIndex)
	{
	case 0:
		{
			return Min;
		}
		break;
			
	case 1:
		{
			temp._x = Min._x; temp._y = Max._y; temp._z = Min._z;
		}
		break;

	case 2:
		{
			temp._x = Max._x; temp._y = Max._y; temp._z = Min._z;
		}
		break;

	case 3:
		{
			temp._x = Max._x; temp._y = Min._y; temp._z = Min._z;
		}
		break;

	case 4:
		{
			temp._x = Min._x; temp._y = Min._y; temp._z = Max._z;
		}
		break;

	case 5:
		{
			temp._x = Min._x; temp._y = Max._y; temp._z = Max._z;
		}
		break;

	case 6:
		{
			return Max;
		}
		break;
			
	case 7:
		{
			temp._x = Max._x; temp._y = Min._y; temp._z = Max._z;
		}
		break;

	default:
		break;
	}

	return temp;
}

//=============================================================================
// 頂点を追加(必要な分だけ拡張する)
//=============================================================================
void AABB::add(const f32 x, const f32 y, const f32 z)
{
	if(Min._x > x){ Min._x = x; }
	if(Min._y > y){ Min._y = y; }
	if(Min._z > z){ Min._z = z; }
	if(Max._x < x){ Max._x = x; }
	if(Max._y < y){ Max._y = y; }
	if(Max._z < z){ Max._z = z; }
}

//=============================================================================
// 頂点を追加(必要な分だけ拡張する)
//=============================================================================
void AABB::add(const VECTOR3& pos)
{
	if(Min._x > pos._x){ Min._x = pos._x; }
	if(Min._y > pos._y){ Min._y = pos._y; }
	if(Min._z > pos._z){ Min._z = pos._z; }
	if(Max._x < pos._x){ Max._x = pos._x; }
	if(Max._y < pos._y){ Max._y = pos._y; }
	if(Max._z < pos._z){ Max._z = pos._z; }
}

//=============================================================================
// AABBを追加(必要な分だけ拡張する)
//=============================================================================
void AABB::add(const AABB& aabb)
{
	if(Min._x > aabb.Min._x){ Min._x = aabb.Min._x; }
	if(Min._y > aabb.Min._y){ Min._y = aabb.Min._y; }
	if(Min._z > aabb.Min._z){ Min._z = aabb.Min._z; }
	if(Max._x < aabb.Max._x){ Max._x = aabb.Max._x; }
	if(Max._y < aabb.Max._y){ Max._y = aabb.Max._y; }
	if(Max._z < aabb.Max._z){ Max._z = aabb.Max._z; }
}

// EOF